<resources>
    <string name="app_name">Material Components Demo</string>
    <string name="search_component_hint">Search material component</string>
    <string name="action_search_title">Search component</string>

    <string name="banner_description">Material Component Banner</string>

    <!--Buttons strings-->

    <string name="button_title">Buttons</string>
    <string name="button_span_title"><![CDATA[
            <p>
                <h1>Buttons</h1>
            </p>
            <p>
                Buttons allow users to take actions, and make choices, with a single tap.
            </p>
        ]]>
    </string>
    <string name="button_span_usage"><![CDATA[
            <p>
                <h3>Usage</h3>
            </p>
            <p>
                Buttons communicate actions that users can take. They are typically placed throughout your UI, in places like:
                <ul>
                    <li>Dialogs
                    <li>Modal windows
                    <li>Forms
                    <li>Cards
                    <li>Toolbars
                </ul>
            </p>
        ]]>
    </string>
    <string name="button_span_anatomy"><![CDATA[
            <p>
                <h3>Anatomy</h3>
            </p>
            <p>
                Buttons contain one required element and four optional elements.
            </p>
        ]]>
    </string>
    <string name="button_span_hierarchy"><![CDATA[
            <p>
                <h3>Hierarchy</h3>
            </p>
            <p>
                <h5>A single, prominent button</h5>
            </p>
            <p>
                A layout should contain a single prominent button that makes it clear that other buttons have less importance in the hierarchy. This high-emphasis button commands the most attention.
            </p>
            <p>
                <h5>Other buttons</h5>
            </p>
            <p>
                An app can show more than one button in a layout at a time, so a high-emphasis button can be accompanied by medium- and low-emphasis buttons that perform less important actions. When using multiple buttons, ensure the available state of one button doesn’t look like the disabled state of another.
            </p>
        ]]>
	</string>
    <string name="button_span_placement"><![CDATA[
            <p>
                <h3>Placement</h3>
            </p>
            <p>
                Multiple button types can be used to express different emphasis levels.
            </p>
        ]]>
        </string>
    <string name="button_span_text_button_usage"><![CDATA[
	        <p>
	            <h3>Text button usage</h3>
	        </p>
            <p>
                Text buttons are typically used for less-pronounced actions, including those located:
                <ul>
                   <li> In dialogs
                   <li> In cards
                 </ul>
                 In cards, text buttons help maintain an emphasis on card content.
            </p>
        ]]>
	</string>
    <string name="button_span_outlined_button_usage"><![CDATA[
            <p>
                <h3>Outlined button usage</h3>
            </p>
            <p>
                Outlined buttons are medium-emphasis buttons. They contain actions that are important, but aren’t the primary action in an app.
            </p>
        ]]>
	</string>
    <string name="button_span_contained_button_usage"><![CDATA[
            <p>
                <h3>Contained button usage</h3>
            </p>
            <p>
                Contained buttons are high-emphasis, distinguished by their use of elevation and fill. They contain actions that are primary to your app.
            </p>
        ]]>
	</string>
    <string name="button_span_toggle_button_usage"><![CDATA[
            <p>
                <h3>Toggle button usage</h3>
            </p>
            <p>
                Toggle buttons can be used to group related options. To emphasize groups of related toggle buttons, a group should share a common container.
            </p>
        ]]>
	</string>
    <string name="button_text_button">Text button</string>
    <string name="button_outlined_button">Outlined button</string>
    <string name="button_contained_button">Contained button</string>
    <string name="button_toggle_button_usage">Toggle button usage</string>
    <string name="button_have_press_outlined_button"> Have press outlined button</string>
    <string name="button_have_press_text_button"> Have press text button</string>
    <string name="button_have_press_contained_button"> Have press contained button</string>

    <!--Cards strings-->

    <string name="card_title">Cards</string>
    <string name="card_span_title"><![CDATA[
            <p>
                <h1>Cards</h1>
            </p>
            <p>
                Cards contain content and actions about a single subject.
            </p>
        ]]>
    </string>
    <string name="card_span_usage"><![CDATA[
            <p>
                <h3>Usage</h3>
            </p>
            <p>
                Cards are surfaces that display content and actions on a single topic.<br><br>
                They should be easy to scan for relevant and actionable information. Elements, like text and images, should be placed on them in a way that clearly indicates hierarchy.
            </p>
        ]]>
    </string>
    <string name="card_span_gestures"><![CDATA[
            <p>
                <h3>Gestures</h3>
            </p>
            <p>
                Gestures should be implemented consistently within a card collection. Frequently used gestures on cards include swipe, pick up and move, and scrolling.
            </p>
        ]]>
    </string>
    <string name="card_span_gestures_swipe"><![CDATA[
            <p>
                <h4>Swipe</h4>
            </p>
            <p>
                A swipe gesture can be performed on a single card at a time, anywhere on that card.<br>
                <br>It can be used to:
            </p>

            <ul>
                <li>Dismiss a card</li>
                <li>Change the state of a card (such as flagging or archiving it)</li>
            </ul>
        ]]>
    </string>
    <string name="card_span_gestures_scrolling"><![CDATA[
            <p>
                <h4>Scrolling</h4>
            </p>
            <p>
                Card content that is taller than the maximum card height is truncated and does not scroll, but can be displayed by expanding the height of a card. A card can expand beyond the maximum height of the screen, in which case the card scrolls within the screen.
            </p>
        ]]>
    </string>
    <string name="card_span_sample"><![CDATA[
            <p>
                <h3>Title</h3>
            </p>
            <br>
            <p>
                Secondary text
            </p>
            <br>
            <p>
                Greyhould divisively hello coldly wonderfully marginally far upon excluding
            </p>
        ]]>
    </string>
    <string name="card_sample_action1">action 1</string>
    <string name="card_sample_action2">action 2</string>
    <string name="card_sample_image_description">content_description_media</string>
    <string name="card_sample_clicked_button1">Action 1 button clicked!</string>
    <string name="card_sample_clicked_button2">Action 2 button clicked!</string>

    <!--Chips strings-->

    <string name="chip_title">Chips</string>
    <string name="chip_span_title"><![CDATA[
            <p>
                <h1>Chips</h1>
            </p>
            <p>
                Chips are compact elements that represent an input, attribute, or action.
            </p>
        ]]>
    </string>
    <string name="chip_span_usage"><![CDATA[
            <p>
                <h3>Usage</h3>
            </p>
            <p>
                Chips allow users to enter information, make selections, filter content, or trigger actions. While buttons are expected to appear consistently and with familiar calls to action, chip should appear dynamically as a group of multiple interactive elements.
            </p>
        ]]>
    </string>
    <string name="chip_span_types"><![CDATA[
            <p>
                <h3>Types</h3>
            </p>
        ]]>
    </string>
    <string name="chip_span_types_input"><![CDATA[
            <p>
                <h4>Input Chips</h4>
            </p>
            <p>
                 Input chip represent information used in fields, such as an entity or different attributes.
            </p>
        ]]>
    </string>
    <string name="chip_span_types_filter"><![CDATA[
            <p>
                <h4>Filter Chips</h4>
            </p>
            <p>
                Filter chip represent filters for a collection.
            </p>
        ]]>
    </string>
    <string name="chip_span_types_choice"><![CDATA[
            <p>
                <h4>Choice Chips</h4>
            </p>
            <p>
                 In sets that contain at least two options, choice chip represent a single selection.
            </p>
        ]]>
    </string>
    <string name="chip_span_types_action"><![CDATA[
            <p>
                <h4>Action Chips</h4>
            </p>
            <p>
                Action chip trigger actions related to primary content.
            </p>
        ]]>
    </string>

    <string name="chip_input1_text">Portland</string>
    <string name="chip_input2_text">Biking</string>

    <string name="chip_input1_toast">Input chip 1 clicked!</string>
    <string name="chip_input2_toast">Input chip 2 clicked!</string>

    <string name="chip_filter1_text">Elevator</string>
    <string name="chip_filter2_text">Dryer</string>
    <string name="chip_filter3_text">Dogs ok</string>

    <string name="chip_filter1_toast">Filter chip 1 clicked!</string>
    <string name="chip_filter2_toast">Filter chip 2 clicked!</string>
    <string name="chip_filter3_toast">Filter chip 3 clicked!</string>

    <string name="chip_action1_text">Turn on lights</string>
    <string name="chip_action2_text">Set alarm</string>

    <string name="chip_action1_toast">Action chip 1 clicked!</string>
    <string name="chip_action2_toast">Action chip 2 clicked!</string>

    <string name="chip_choice1_text">Medium</string>
    <string name="chip_choice2_text">Soft</string>
    <string name="chip_choice3_text">Extra Soft</string>

    <string name="chip_choice1_toast">Choice chip 1 clicked!</string>
    <string name="chip_choice2_toast">Choice chip 2 clicked!</string>
    <string name="chip_choice3_toast">Choice chip 3 clicked!</string>

    <!--Dialogs strings-->

    <string name="dialog_title">Dialogs</string>
    <string name="dialog_span_title"><![CDATA[
            <p>
                <h1>Dialogs</h1>
            </p>
            <p>
                Dialogs inform users about a task and can contain critical information, require decisions, or involve multiple tasks.
            </p>
        ]]>
    </string>
    <string name="dialog_span_usage"><![CDATA[
            <p>
                <h3>Usage</h3>
            </p>
            <p>
                A dialog is a type of modal window that appears in front of app content to provide critical information or ask for a decision. Dialogs disable all app functionality when they appear, and remain on screen until confirmed, dismissed, or a required action has been taken.
                <br><br>
                Dialogs are purposefully interruptive, so they should be used sparingly.
            </p>
        ]]>
    </string>
    <string name="dialog_span_when_to_use"><![CDATA[
            <p>
                <h3>When to use</h3>
            </p>
            <p>
                Dialogs should be used for:<br>
                <ul>
                <li>Errors that block an app’s normal operation</li>
                <li>Critical information that requires a specific user task, decision, or acknowledgement</li>
                </ul>
            </p>
        ]]>
    </string>
    <string name="dialog_span_types"><![CDATA[
            <p>
                <h4>Types</h4>
            </p>
        ]]>
    </string>
    <string name="dialog_span_types_alert"><![CDATA[
            <p>
                <h3>Alert Dialog</h3>
            </p>
            <p>
                Alert dialogs interrupt users with urgent information, details, or actions.<br>
            </p>
        ]]>
    </string>
    <string name="dialog_span_types_simple"><![CDATA[
            <p>
                <h3>Simple Dialog</h3>
            </p>
            <p>
               Simple dialogs can display items that are immediately actionable when selected. They don’t have text buttons.
               <br><br>
               As simple dialogs are interruptive, they should be used sparingly. Alternatively, dropdown menus provide options in a non-modal, less disruptive way.</p>
        ]]>
    </string>
    <string name="dialog_span_types_confirmation"><![CDATA[
            <p>
                <h3>Confirmation Dialog</h3>
            </p>
            <p>
                Confirmation dialogs give users the ability to provide final confirmation of a choice before committing to it, so they have a chance to change their minds if necessary.
                <br><br>
                If the user confirms a choice, it’s carried out. Otherwise, the user can dismiss the dialog. For example, users can listen to multiple ringtones but only make a final selection upon tapping “OK.”
            </p>
        ]]>
    </string>
    <string name="dialog_alert_button">Alert dialog</string>
    <string name="dialog_simple_button">Simple dialog</string>
    <string name="dialog_confirmation_button">Confirmation dialog</string>
    <string name="dialog_alert_discard">Discard</string>
    <string name="dialog_text_cancel">Cancel</string>
    <string name="dialog_alert_draft">Discard Draft?</string>
    <string name="dialog_simple_option">View options</string>
    <string name="dialog_simple_accept">Accept</string>
    <string name="dialog_confirmation_ringtone">Phone Ringtone</string>
    <string name="dialog_confirmation_ok">OK</string>
    <string-array name="dialog_array_simple">
        <item>Photos</item>
        <item>Movies</item>
        <item>All</item>
    </string-array>
    <string-array name="dialog_array_confirmation">
        <item>None</item>
        <item>Callisto</item>
        <item>Ganymede</item>
        <item>Luna</item>
        <item>Oberon</item>
        <item>Phobos</item>
    </string-array>

    <!--Pickers strings-->

    <string name="picker_title">Pickers</string>
    <string name="picker_span_title"><![CDATA[
            <p>
                <h1>Pickers</h1>
            </p>
            <p>
                Date pickers let users select a date, or a range of dates.
            </p>
        ]]>
    </string>
    <string name="picker_span_usage"><![CDATA[
            <p>
                <h3>Usage</h3>
            </p>
            <p>
                Date pickers let users select a date or range of dates. They should be suitable for the context in which they appear.
                Date pickers can be embedded into:
                <ul>
                    <li>Dialogs on mobile
                    <li>Text field dropdowns on desktop
                </ul>
            </p>
        ]]>
    </string>
    <string name="picker_span_mobile_calendar_pickers"><![CDATA[
            <p>
                <h3>Mobile calendar pickers</h3>
            </p>
            <p>
                Mobile calendar pickers can be used to select dates in the near future or past, when it’s useful to see them in a calendar month format. They are displayed in a dialog.
                Common use cases include:
                <ul>
                    <li>Making a restaurant reservation
                    <li>Scheduling a meeting
                </ul>
                They aren’t ideal for selecting dates in the distant past or future that require more navigation, such as entering a birth date or expiration date.
                Mobile calendar pickers allow selection of a single date and year.
            </p>
        ]]>
    </string>
    <string name="picker_span_mobile_date_range_pickers"><![CDATA[
            <p>
                <h3>Mobile date range pickers</h3>
            </p>
            <p>
                Mobile date range pickers allow selection of a range of dates. They cover the entire screen.
                Common use cases include:
                <ul>
                    <li>Booking a flight
                    <li>Reserving a hotel
                </ul>
            </p>
        ]]>
    </string>
    <string name="picker_span_mobile_date_input_pickers"><![CDATA[
            <p>
                <h3>Mobile date input pickers</h3>
            </p>
            <p>
                Mobile date input pickers allow the manual entry of dates using the numbers on a keyboard. Users can input a date or a range of dates in a dialog.
                The mobile date input picker can be accessed from any other mobile date picker, via the edit icon.
            </p>
        ]]>
    </string>
    <string name="picker_button_range_picker">Click to show the date range picker</string>
    <string name="picker_date_range_picker">Date Range Picker</string>
    <string name="picker_button_calendar_picker">Show the calendar picker</string>
    <string name="picker_calendar_picker">calendar picker</string>
    <string name="picker_launch_failure">The launch of the selected picker has failed</string>

    <!--Progress Indicator strings-->

    <string name="progress_indicator_title">Progress Indicator</string>
    <string name="progress_indicator_span_title"><![CDATA[
            <p>
                 <h1>Progress Indicator</h1>
            </p>
            <p>
            Progress indicators express an unspecified wait time or display the length of a process.
            </p>
        ]]>
     </string>
    <string name="progress_indicator_span_usage"><![CDATA[
            <p>
                 <h3>Usage</h3>
            </p>
            <p>
            Progress indicators inform users about the status of ongoing processes, such as loading an app, submitting a form, or saving updates. They communicate an app’s state and indicate available actions, such as whether users can navigate away from the current screen.
            </p>
        ]]>
    </string>
    <string name="progress_indicator_span_circular"><![CDATA[
            <p>
                 <h3>Circular Progress Indicator</h3>
            </p>
            <p>
            Circular progress indicators display progress by animating an indicator along an invisible circular track in a clockwise direction. They can be applied directly to a surface, such as a button or card.
            </p>
        ]]>
    </string>
    <string name="progress_indicator_span_linear"><![CDATA[
            <p>
                 <h3>Linear Progress Indicator</h3>
            </p>
            <p>
             Linear progress indicators display progress by animating an indicator along the length of a fixed, visible track. The behavior of the indicator is dependent on whether the progress of a process is known.
            </p>
        ]]>
    </string>
    <string name="progress_button_submit">submit</string>

    <!--Selection Controls strings-->

    <string name="selection_control_title">Selection Control</string>
    <string name="selection_control_span_title"><![CDATA[
            <p>
                <h1>Selection Control</h1>
            </p>
            <p>
                Selection controls allow the user to select options.
            </p>
        ]]>
    </string>
    <string name="selection_control_span_usage"><![CDATA[
            <p>
                <h3>Usage</h3>
            </p>
            <p>
                Selection controls allow users to complete tasks that involve making choices such as selecting options, or switching settings on or off. Selection controls are found on screens that ask users to make decisions or declare preferences such as settings or dialogs.
            </p>
        ]]>
    </string>
    <string name="selection_control_span_checkbox"><![CDATA[
            <p>
                <h3>Checkboxes</h3>
            </p>
            <p>
                Checkboxes allow the user to select one or more items from a set. Checkboxes can be used to turn an option on or off.
            </p>
        ]]>
    </string>
    <string name="selection_control_span_radio_button"><![CDATA[
            <p>
                <h3>Radio Bottons</h3>
            </p>
            <p>
                Radio buttons allow the user to select one option from a set. Use radio buttons when the user needs to see all available options. If available options can be collapsed, consider using a dropdown menu because it uses less space.
            </p>
        ]]>
    </string>
    <string name="selection_control_span_switch"><![CDATA[
            <p>
                <h3>Switches</h3>
            </p>
            <p>
                Switches toggle the state of a single item on or off. They are the preferred way to adjust settings on mobile.
            </p>
        ]]>
    </string>
    <string name="selection_switch_text">Setting One</string>
    <string name="selection_checkbox_text_one">One</string>
    <string name="selection_checkbox_text_two">Two</string>
    <string name="selection_checkbox_text_three">Three</string>
    <string name="selection_radio_button_text_one">One</string>
    <string name="selection_radio_button_text_two">Two</string>
    <string name="selection_radio_button_text_three">Three</string>
    <string name="selection_radio_button_text_four">Three</string>

    <!--Snackbars strings-->

    <string name="snackbar_title">Snackbar</string>
    <string name="snackbar_span_title"><![CDATA[
            <p>
                 <h1>Snackbar</h1>
            </p>
            <p>
            Selection controls allow the user to select options.
            </p>
        ]]>
    </string>
    <string name="snackbar_span_usage"><![CDATA[
            <p>
                 <h3>Usage</h3>
            </p>
            <p>
             Snackbars inform users of a process that an app has performed or will perform. They appear temporarily, towards the bottom of the screen. They shouldn’t interrupt the user experience, and they don’t require user input to disappear
            </p>
        ]]>
    </string>
    <string name="snackbar_span_anatomy"><![CDATA[
            <p>
                 <h3>Anatomy</h3>
            </p>
            <p>
            There are 3 types of Snackbars: Text Label that directly relates to the process being performed. On mobile, the text label can contain up to two lines of text; Container (rectangular) with a grey background. Containers should be
            completely opaque, so that text labels remain legible; Action, Snackbars can display a single text button that lets users take action on a process performed by the app. Snackbars shouldn’t be the only way
            </p>
        ]]>
    </string>
    <string name="snackbar_span_placement"><![CDATA[
            <p>
                 <h3>Placement</h3>
            </p>
            <p>
            Snackbars should be placed at the bottom of a UI, in front of app content. Avoid placing a snackbar in front of frequently used touch targets or navigation.
            </p>
        ]]>
    </string>
    <string name="snackbar_button">Snackbar</string>
    <string name="snackbar_button_undo">Snackbar + Action</string>
    <string name="snackbar_text_visible">THIS IS A SNACKBAR</string>
    <string name="snackbar_undo">UNDO</string>

    <!--Text Fields strings-->

    <string name="text_field_title">Text fields</string>
    <string name="text_field_span_title"><![CDATA[
            <p>
                <h1>Text fields</h1>
            </p>
            <p>
                Text fields let users enter and edit text.
            </p>
        ]]>
    </string>
    <string name="text_field_span_usage"><![CDATA[
            <p>
                <h3>Usage</h3>
            </p>
            <p>
                Text fields allow users to enter text into a UI. They typically appear in forms and dialogs.
            </p>
        ]]>
    </string>
    <string name="text_field_span_types"><![CDATA[
            <p>
                <h3>Types</h3>
            </p>
            <p>
                Text fields come in two types:
                <ul>
                    <li>Filled text fields
                    <li>Outlined text fields
                </ul>
                Both types of text fields use a container to provide , making the fields discoverable in layouts.
                Both types of text fields provide the same functionality: a clear affordance for interaction. The type of text field you use can depend on style alone.
            </p>
        ]]>
    </string>
    <string name="text_field_span_filled"><![CDATA[
            <p>
                <h3>Filled text field</h3>
            </p>
            <p>
                Filled text fields have more visual emphasis than outlined text fields, making them stand out when surrounded by other content and components.
            </p>
        ]]>
    </string>
    <string name="text_field_span_outlined"><![CDATA[
            <p>
                <h3>Outlined text field</h3>
            </p>
            <p>
                Outlined text fields have less visual emphasis than filled text fields. When they appear in places like forms, where many text fields are placed together, their reduced emphasis helps simplify the layout.
            </p>
        ]]>
    </string>
    <string name="text_field_span_icon"><![CDATA[
            <p>
                <h3>Icons</h3>
            </p>
            <p>
                Icons in text fields are optional. Text field icons can describe valid input methods (such as a microphone icon), provide affordances to access additional functionality (such as clearing the content of a field), and can express an error.
            </p>
        ]]>
    </string>
    <string name="text_field_label_filled">Filled text field</string>
    <string name="text_field_label_outlined">Outlined text field</string>
    <string name="text_field_label_password">Password</string>
    <string name="text_field_error">Password can\'t be shorter than 8 characters</string>
    <string name="text_field_button">Submit</string>
    <string name="text_field_toast">Password suitable</string>

    <!--Tooltips strings-->

    <string name="tooltip_title">Tooltips</string>
    <string name="tooltip_span_title"><![CDATA[
            <p>
                <h1>Tooltips</h1>
            </p>
            <p>
                Tooltips display informative text when users hover over, focus on, or tap an element.
            </p>
        ]]>
    </string>
    <string name="tooltip_span_usage"><![CDATA[
            <p>
                <h3>Usage</h3>
            </p>
            <p>
                When activated, tooltips display a text label identifying an element, such as a description of its function.
            </p>
        ]]>
    </string>
    <string name="tooltip_span_behavior"><![CDATA[
            <p>
                <h3>Behavior</h3>
            </p>
            <p>
                A tooltip is displayed upon tapping and holding a screen element or component (on mobile) or hovering over it (desktop). Continuously display the tooltip as long as the user long-presses or hovers over the element.
            </p>
        ]]>
    </string>
    <string name="tooltip_image_description_placement">Placement</string>
    <string name="tooltip_image_description_desktop">Desktop</string>


    <!--Backdrop strings-->

    <string name="backdrop_title">Backdrop</string>
    <string name="backdrop_span_title"><![CDATA[
        <p>
        <h1>Backdrop</h1>
        </p>
        <p>A backdrop appears behind all other surfaces in an app, displaying contextual and actionable content.</p>]]>
    </string>
    <string name="backdrop_span_usage"><![CDATA[
        <p>
        <h3>Usage</h3>
        </p>
        <p>A backdrop is composed of two surfaces: a back layer and a front layer. The back layer displays actions and context, and these control and inform the front layer\'s content.</p>]]>
    </string>
    <string name="backdrop_span_anatomy"><![CDATA[
        <p>
        <h3>Anatomy</h3>
        </p>
        <p>A backdrop consists of a back layer, a front layer, and an optional subheader. Either the back layer or the front layer can be active at a time.</p>
        <p>
        <h5>Active front layer</h5>
        </p>
        <p>The front layer always appears in front of the back layer. It is displayed at full width and holds primary content.</p>
        <p>
        <h5>Active back layer</h5>
        </p>
        <p>The back layer appears at the lowest elevation (0dp) in an app, filling the entire background. It holds actionable content that is relevant to the front layer.</p>]]>
    </string>
    <string name="backdrop_span_behavior"><![CDATA[
        <p>
             <h3>Behavior</h3>
        </p>
        <p>To reveal the back layer, interact with any actions that appear on it.</p>
        <p>
              <h5>Concealing the back layer</h5>
        </p>
        <p>The back layer can be concealed by either interacting with the front layer or tapping a conceal affordance on either layer.</p>
        <p>
              <h5>Content scrolling</h5>
        </p>
        <p>Content on the front layer has different scrolling behaviors (and restrictions) than content on the back layer.</p>]]>
    </string>
    <string name="backdrop_image_descriptor_anatomy">Anatomy</string>
    <string name="backdrop_image_descriptor_behavior">Behavior</string>

</resources>
